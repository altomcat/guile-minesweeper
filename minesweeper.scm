(define-module (minesweeper)
  ;; #:use-module (srfi srfi-1)
  ;; #:export (field-show
  ;; 	    field-init)
  #:export (frob)
  )
(define (frob x ) (* 2 x))

(define rows 4)
(define cols 5)
(define mines-field (make-array 0 rows cols))
(array-set! mines-field -1 0 1)
(array-set! mines-field -1 0 3)
(array-set! mines-field -1 1 2)
(array-set! mines-field -1 2 2)

(define (mine? field i j)
  (equal? -1 (and (array-in-bounds? field i j)
		  (array-ref field i j))))

(define (calc field i j)
  (let ((cur (array-ref field i j))
	(ij '((-1 -1) (0 -1) (1 -1) (-1 0) (1 0) (-1 1) (0 1) (1 1))))
    (unless (mine? field i j)
      (let ((res (fold + 0
		       (map (lambda (v)
			      (let ((ri (+ i (car v)))
				    (rj (+ j (cadr v))))
				(or (and (mine? mines-field ri rj)
					 1)
				    0)))
			    ij))))
	(when (> res 0)
	  (array-set! field res i j))))))

(define  (field-show field)
  (define (toString value)
    (cond
     ((< value 0) "*")
     ((= value 0) ".")
     (else value)))
  (let* ((dimensions (array-dimensions mines-field))
	 (rows (car dimensions))
	 (cols (cadr dimensions)))
    (for-each (lambda (i)
		(for-each (lambda (j)
			    (format #t "~2a " (toString (array-ref field i j))))
			  (iota cols))
		(newline))
	      (iota rows))))

(define (field-init)
  (let* ((dimensions (array-dimensions mines-field))
	 (rows (car dimensions))
	 (cols (cadr dimensions)))
    (for-each (lambda (i)
		(for-each (lambda (j)
			    (calc mines-field i j))
			  (iota cols)))
	      (iota rows)))
  (field-show mines-field))

